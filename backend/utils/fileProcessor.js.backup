const fs = require('fs');
const path = require('path');
const pdfParse = require('pdf-parse');
const mammoth = require('mammoth');
const JSZip = require('jszip');
const crypto = require('crypto');

// Import universal business requirements extractor
const { extractBusinessRequirements: universalExtract } = require('./universalBusinessExtractor');

// Universal business requirements extractor is now used for all file types
// This provides consistent, high-quality business element detection across all document types

// OLD BUSINESS ELEMENT DETECTION SYSTEM REMOVED - Now using Universal Business Extractor



  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    // SIMPLE section detection - only exclude very short ALL CAPS
    if (line.match(/^[A-Z][A-Z\s]+$/) && line.length < 15) {
      currentSection = line;
      continue;
    }

    // Check high priority patterns first
    for (const pattern of config.patterns.highPriority) {
      if (pattern.regex.test(line)) {
        businessElements.push({
          type: pattern.type,
          text: line,
          lineNumber: i + 1,
          section: currentSection,
          priority: pattern.priority
        });
        break;
      }
    }
    
    // SIMPLE, CONSISTENT detection - same logic for all documents
    if (line.length > 60 && !line.match(/^[A-Z][A-Z\s]+$/) && line.length < 200) {
      // Check if line contains business-related patterns
      const hasBusinessContent = 
        // Structured content patterns
        line.match(/^[0-9]+\.\s+/) ||                    // Numbered lists
        line.match(/^[0-9]+\)\s+/) ||                    // Numbered with parenthesis
        line.match(/^[a-z]\)\s+/) ||                     // Lettered lists
        line.match(/^[â€¢\-*]\s+/) ||                      // Bullet points
        line.match(/^Scenario\s+[0-9]+/i) ||                   // Scenarios
        line.match(/^Acceptance\s+Criteria/i) ||         // Acceptance criteria headers
        line.match(/^Acceptance\s+Criteria\s+[0-9]+/i) || // Numbered acceptance criteria
        line.match(/^AC\s*[0-9]+/i) ||                         // AC format
        line.match(/^Requirement\s+[0-9]+/i) ||                // Requirements
        line.match(/^BR\s*[0-9]+/i) ||                         // BR format
        line.match(/^(Given|When|Then|And|But)\s+/i) ||  // Gherkin
        // Business function patterns
        line.toLowerCase().includes('create') ||
        line.toLowerCase().includes('generate') ||
        line.toLowerCase().includes('export') ||
        line.toLowerCase().includes('import') ||
        line.toLowerCase().includes('update') ||
        line.toLowerCase().includes('process') ||
        line.toLowerCase().includes('handle') ||
        line.toLowerCase().includes('manage') ||
        line.toLowerCase().includes('track') ||
        line.toLowerCase().includes('calculate') ||
        // Modal verb patterns - ONLY if they contain specific business content
        (line.toLowerCase().includes('should') && line.length > 50 && 
         !line.toLowerCase().includes('the system should support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('must') && line.length > 50 && 
         !line.toLowerCase().includes('the system must support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('will') && line.length > 50 && 
         !line.toLowerCase().includes('the system will support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('shall') && line.length > 50 && 
         !line.toLowerCase().includes('the system shall support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('can') && line.length > 50 && 
         !line.toLowerCase().includes('the system can support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('has') && line.length > 50 && 
         !line.toLowerCase().includes('the system has support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('provides') && line.length > 50 && 
         !line.toLowerCase().includes('the system provides support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('supports') && line.length > 50 && 
         !line.toLowerCase().includes('the system supports') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('allows') && line.length > 50 && 
         !line.toLowerCase().includes('the system allows support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('enables') && line.length > 50 && 
         !line.toLowerCase().includes('the system enables support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate'))) ||
        (line.toLowerCase().includes('includes') && line.length > 50 && 
         !line.toLowerCase().includes('the system includes support') && 
         (line.toLowerCase().includes('create') || line.toLowerCase().includes('generate') || 
          line.toLowerCase().includes('export') || line.toLowerCase().includes('import') || 
          line.toLowerCase().includes('update') || line.toLowerCase().includes('process') || 
          line.toLowerCase().includes('handle') || line.toLowerCase().includes('manage') || 
          line.toLowerCase().includes('track') || line.toLowerCase().includes('calculate')));
      
      if (hasBusinessContent) {
        // Aggressive filtering to avoid generic system statements and non-requirements
        const isObviousNonRequirement = 
          line.length < 20 ||                                                    // Very short lines
          line.match(/^[A-Z\s]+$/) && line.length < 15 ||                       // Short ALL CAPS
          line.match(/^[0-9\s]+$/) && line.length < 15 ||                       // Short numbers
          line.toLowerCase().includes('page') && line.length < 25 ||             // Very short page references
          line.toLowerCase().includes('section') && line.length < 25 ||          // Very short section references
          line.toLowerCase().includes('chapter') && line.length < 25 ||          // Very short chapter references
          line.toLowerCase().includes('table of contents') ||                    // Table of contents
          line.toLowerCase().includes('index') ||                                // Index
          line.toLowerCase().includes('glossary') ||                             // Glossary
          line.toLowerCase().includes('references') ||                           // References
          line.toLowerCase().includes('bibliography') ||                         // Bibliography
          // Filter out ALL generic system statements regardless of length
          line.toLowerCase().includes('the system should support') ||  // Generic system support statements
          line.toLowerCase().includes('the system must support') ||    // Generic system support statements
          line.toLowerCase().includes('the system will support') ||    // Generic system support statements
          line.toLowerCase().includes('the system shall support') ||   // Generic system support statements
          line.toLowerCase().includes('the system can support') ||     // Generic system support statements
          line.toLowerCase().includes('the system has support') ||     // Generic system support statements
          line.toLowerCase().includes('the system provides support') || // Generic system support statements
          line.toLowerCase().includes('the system supports') ||        // Generic system support statements
          line.toLowerCase().includes('the system allows support') ||  // Generic system support statements
          line.toLowerCase().includes('the system enables support') || // Generic system support statements
          line.toLowerCase().includes('the system includes support') || // Generic system support statements

          // Filter out ALL generic patterns regardless of length
          line.toLowerCase().includes('access has been granted') ||     // Generic access statements
          line.toLowerCase().includes('us only') ||                    // Generic location statements
          line.toLowerCase().includes('narrative') ||                 // Generic narrative statements
          line.toLowerCase().includes('sequence flow') ||             // Generic flow statements
          line.toLowerCase().includes('message') ||                   // Generic message statements
          line.toLowerCase().includes('timer') ||                     // Generic timer statements
          line.toLowerCase().includes('intermediate') ||              // Generic intermediate statements
          line.toLowerCase().includes('data object') ||               // Generic data object statements
          line.toLowerCase().includes('data store') ||                // Generic data store statements
          line.toLowerCase().includes('association') ||               // Generic association statements
          line.toLowerCase().includes('default sequence flow') ||     // Generic flow statements
          line.toLowerCase().includes('other intermediate') ||        // Generic intermediate statements
          line.toLowerCase().includes('intermediate event') ||        // Generic event statements
          line.toLowerCase().includes('version') ||                   // Generic version statements
          line.toLowerCase().includes('date') ||                      // Generic date statements
          line.toLowerCase().includes('description') ||               // Generic description statements
          line.toLowerCase().includes('author') ||                    // Generic author statements
          line.toLowerCase().includes('document creation') ||         // Generic document statements
          line.toLowerCase().includes('document name') ||             // Generic document statements
          line.toLowerCase().includes('programme and project name') || // Generic project statements
          line.toLowerCase().includes('academic division online product sales process') || // Generic process statements
          line.toLowerCase().includes('flexible selling') ||           // Generic selling statements
          line.toLowerCase().includes('title-by-title project') ||    // Generic project statements
          // Additional generic patterns that are getting through
          line.toLowerCase().includes('page') && !line.toLowerCase().includes('create') && !line.toLowerCase().includes('update') && !line.toLowerCase().includes('process') ||  // Page references without actions
          line.toLowerCase().includes('customer') && !line.toLowerCase().includes('create') && !line.toLowerCase().includes('update') && !line.toLowerCase().includes('process') && !line.toLowerCase().includes('export') && !line.toLowerCase().includes('import') ||  // Customer without actions
          line.toLowerCase().includes('sales team') && !line.toLowerCase().includes('create') && !line.toLowerCase().includes('update') && !line.toLowerCase().includes('process') && !line.toLowerCase().includes('export') && !line.toLowerCase().includes('import') ||  // Sales team without actions
          line.toLowerCase().includes('oup') && !line.toLowerCase().includes('create') && !line.toLowerCase().includes('update') && !line.toLowerCase().includes('process') && !line.toLowerCase().includes('export') && !line.toLowerCase().includes('import');  // OUP without actions
        
        if (!isObviousNonRequirement) {
          businessElements.push({
            type: 'System Requirement',
            text: line,
            lineNumber: i + 1,
            section: currentSection,
            priority: 'medium'
          });
        }
        continue;
      }
    }

    // Check medium priority patterns - SIMPLE and CONSISTENT
    for (const pattern of config.patterns.mediumPriority) {
      if (pattern.regex.test(line) && line.length > 60) {
        // Simple filtering to ensure it's actually a business requirement
        const isActualRequirement = 
          line.length > 40 && // Must be substantial
          line.split(' ').length > 4 && // Must have at least 5 words
          !line.match(/^the system (should|must|will|can|has|provides|supports|allows|enables|includes)/i) && // Not generic system statements
          !line.match(/^(page|section|screen|button|field|menu|tab|link|data|information|display|access|support|provide|show|view)/i); // Not generic UI references
        
        if (isActualRequirement) {
          businessElements.push({
            type: pattern.type,
            text: line,
            lineNumber: i + 1,
            section: currentSection,
            priority: pattern.priority
          });
        }
        break;
      }
    }

    // Check medium priority keywords - SIMPLE and CONSISTENT
    for (const keywordPattern of config.patterns.mediumKeywords) {
      const hasKeyword = keywordPattern.keywords.some(keyword => 
        line.toLowerCase().includes(keyword.toLowerCase())
      );
      
      if (hasKeyword) {
        // Simple restriction: line must have substantial business content
        const hasSubstantialContent = 
          line.length > 50 && // Must be substantial
          line.split(' ').length > 4 && // Must have at least 5 words
          (line.includes(' ') || line.includes('-') || line.includes(':')) && // Must have structure
          !line.match(/^[A-Z\s]+$/) && // Must not be just ALL CAPS
          !line.match(/^the system (should|must|will|can|has|provides|supports|allows|enables|includes)/i); // Must not be generic system statements
        
        if (hasSubstantialContent) {
          businessElements.push({
            type: keywordPattern.type,
            text: line,
            lineNumber: i + 1,
            section: currentSection,
            priority: 'medium'
          });
        }
        break;
      }
    }

    // Check low priority patterns - SIMPLE and CONSISTENT
    for (const keywordPattern of config.patterns.lowPriority) {
      const hasKeyword = keywordPattern.keywords.some(keyword => 
        line.toLowerCase().includes(keyword)
      );
      
      if (hasKeyword) {
        // Simple restriction: must be high-quality business content
        const isHighQuality = 
          line.length > 60 && // Must be substantial
          line.includes(' ') && // Must have multiple words
          line.split(' ').length > 6 && // Must have at least 7 words
          !line.match(/^[A-Z\s]+$/) && // Must not be just ALL CAPS
          !line.match(/^[0-9\s]+$/) && // Must not be just numbers
          line.match(/[a-z]/i) && // Must contain letters
          !line.match(/^the system (should|must|will|can|has|provides|supports|allows|enables|includes)/i) && // Must not be generic system statements
          !line.match(/^(page|section|screen|button|field|menu|tab|link|data|information|display|access|support|provide|show|view)/i); // Must not be generic UI references
        
        if (isHighQuality) {
          businessElements.push({
            type: keywordPattern.type,
            text: line,
            lineNumber: i + 1,
            section: currentSection,
            priority: 'low'
          });
        }
        break;
      }
    }
  }

// OLD BUSINESS ELEMENT DETECTION SYSTEM COMPLETELY REMOVED



// OLD BUSINESS ELEMENT DETECTION SYSTEM COMPLETELY REMOVED


// const fileCache = new Map();
// const CACHE_MAX_SIZE = 100;

// function // clearFileCache() {
//   console.log('ðŸ§¹ No file cache to clear');
// }

// File type detection
const isImageFile = (mimeType, extension) => {
  const imageMimes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp', 'image/tiff', 'image/webp', 'image/svg+xml'];
  const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg'];
  return imageMimes.includes(mimeType) || imageExtensions.includes(extension.toLowerCase());
};

const isExcelFile = (mimeType, extension) => {
  const excelMimes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.oasis.opendocument.spreadsheet'];
  const excelExtensions = ['.xls', '.xlsx', '.ods'];
  return excelMimes.includes(mimeType) || excelExtensions.includes(extension.toLowerCase());
};

const isPowerPointFile = (mimeType, extension) => {
  const pptMimes = ['application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'application/vnd.oasis.opendocument.presentation'];
  const pptExtensions = ['.ppt', '.pptx', '.odp'];
  return pptMimes.includes(mimeType) || pptExtensions.includes(extension.toLowerCase());
};

const isVisioFile = (mimeType, extension) => {
  const visioMimes = ['application/octet-stream']; // VSDX files often have this MIME type
  const visioExtensions = ['.vsd', '.vsdx'];
  return visioMimes.includes(mimeType) || visioExtensions.includes(extension.toLowerCase());
};

// Helper function to analyze image content deterministically
function analyzeImageContent(fileName, extension) {
  // Analyze image based on filename and extension for business context
  const name = fileName.toLowerCase();
  let businessElements = [];
  let description = '';
  
  // Analyze filename for business context
  if (name.includes('workflow') || name.includes('process') || name.includes('diagram')) {
    description = 'This image appears to contain workflow or process diagrams that likely represent business processes.';
    businessElements.push({
      type: 'Business Process',
      text: 'Workflow/Process Diagram',
      lineNumber: 1,
      section: 'Image Analysis'
    });
  }
  
  if (name.includes('ui') || name.includes('interface') || name.includes('screen')) {
    description = 'This image appears to contain user interface elements that represent system functionality.';
    businessElements.push({
      type: 'System Requirement',
      text: 'User Interface Design',
      lineNumber: 2,
      section: 'Image Analysis'
    });
  }
  
  if (name.includes('data') || name.includes('chart') || name.includes('graph')) {
    description = 'This image appears to contain data visualizations that may represent business metrics or processes.';
    businessElements.push({
      type: 'Business Process',
      text: 'Data Visualization',
      lineNumber: 3,
      section: 'Image Analysis'
    });
  }
  
  if (name.includes('architecture') || name.includes('system') || name.includes('design')) {
    description = 'This image appears to contain system architecture or design diagrams.';
    businessElements.push({
      type: 'System Requirement',
      text: 'System Architecture',
      lineNumber: 4,
      section: 'Image Analysis'
    });
  }
  
  if (name.includes('user') || name.includes('persona') || name.includes('profile')) {
    description = 'This image appears to contain user interface elements that represent system functionality.';
    businessElements.push({
      type: 'User Action',
      text: 'User Profile/Persona',
      lineNumber: 5,
      section: 'Image Analysis'
    });
  }
  
  // Default analysis if no specific patterns found
  if (businessElements.length === 0) {
    description = 'This image file contains visual content that requires manual analysis to identify business requirements.';
    businessElements.push({
      type: 'Business Process',
      text: 'Visual Content Analysis Required',
      lineNumber: 1,
      section: 'Image Analysis'
    });
  }
  
  // Count business elements
  const count = businessElements.length;
  const breakdown = {
    processes: businessElements.filter(e => e.type === 'Business Process').length,
    requirements: businessElements.filter(e => e.type === 'System Requirement').length,
    decisions: businessElements.filter(e => e.type === 'Decision Point').length,
    steps: businessElements.filter(e => e.type === 'Process Step').length,
    flows: businessElements.filter(e => e.type === 'Business Flow').length,
    userActions: businessElements.filter(e => e.type === 'User Action').length
  };
  
  return {
    description,
    businessElements: {
      count,
      elements: businessElements,
      breakdown
    }
  };
}

/**
 * Enhanced Visio (.vsdx) flowchart analysis function
 * Parses actual XML content to extract visual elements, shapes, and flow structure
 * @param {Buffer} buffer - File buffer
 * @param {string} originalName - Original filename
 * @returns {Object} Comprehensive flowchart analysis
 */
async function analyzeVisioFlowchart(buffer, originalName) {
  try {
    const zip = new JSZip();
    const zipContent = await zip.loadAsync(buffer);
    
    let extractedContent = '';
    let businessElements = [];
    let elementCount = 0;
    
    // Extract Visio drawing pages
    const drawingFiles = Object.keys(zipContent.files).filter(file => 
      file.includes('visio/pages/page') && file.endsWith('.xml')
    );
    
    if (drawingFiles.length === 0) {
      // Fallback to older Visio format
      const oldDrawingFiles = Object.keys(zipContent.files).filter(file => 
        file.includes('visio/drawing') && file.endsWith('.xml')
      );
      if (oldDrawingFiles.length > 0) {
        extractedContent += `\n\n## Visio Drawing Analysis:\n`;
        extractedContent += `Found ${oldDrawingFiles.length} drawing files\n`;
        
        for (const drawingFile of oldDrawingFiles) {
          try {
            const drawingXml = await zipContent.files[drawingFile].async('string');
            const analysis = analyzeVisioXmlContent(drawingXml, `Drawing ${drawingFile}`);
            businessElements.push(...analysis.elements);
            extractedContent += analysis.content;
          } catch (error) {
            console.error(`Error processing drawing file ${drawingFile}:`, error);
          }
        }
      }
    } else {
      extractedContent += `\n\n## Visio Page Analysis:\n`;
      extractedContent += `Found ${drawingFiles.length} pages in flowchart\n`;
      
      // Process each page
      for (let i = 0; i < drawingFiles.length; i++) {
        const pageFile = drawingFiles[i];
        try {
          const pageXml = await zipContent.files[pageFile].async('string');
          const analysis = analyzeVisioXmlContent(pageXml, `Page ${i + 1}`);
          businessElements.push(...analysis.elements);
          extractedContent += analysis.content;
        } catch (error) {
          console.error(`Error processing page file ${pageFile}:`, error);
        }
      }
    }
    
    // Extract master shapes and stencils for additional context
    const masterFiles = Object.keys(zipContent.files).filter(file => 
      file.includes('visio/masters/master') && file.endsWith('.xml')
    );
    
    if (masterFiles.length > 0) {
      extractedContent += `\n\n## Master Shapes Analysis:\n`;
      extractedContent += `Found ${masterFiles.length} master shape definitions\n`;
      
      for (const masterFile of masterFiles) {
        try {
          const masterXml = await zipContent.files[masterFile].async('string');
          const masterAnalysis = analyzeVisioMasterShapes(masterXml);
          businessElements.push(...masterAnalysis.elements);
          extractedContent += masterAnalysis.content;
        } catch (error) {
          console.error(`Error processing master file ${masterFile}:`, error);
        }
      }
    }
    
    // Extract document properties for context
    const docPropsFile = zipContent.files['docProps/core.xml'];
    if (docPropsFile) {
      try {
        const docPropsXml = await docPropsFile.async('string');
        const titleMatch = docPropsXml.match(/<dc:title>(.*?)<\/dc:title>/);
        const subjectMatch = docPropsXml.match(/<dc:subject>(.*?)<\/dc:subject>/);
        const descriptionMatch = docPropsXml.match(/<dc:description>(.*?)<\/dc:description>/);
        
        if (titleMatch || subjectMatch || descriptionMatch) {
          extractedContent += `\n\n## Document Properties:\n`;
          if (titleMatch) extractedContent += `Title: ${titleMatch[1]}\n`;
          if (subjectMatch) extractedContent += `Subject: ${subjectMatch[1]}\n`;
          if (descriptionMatch) extractedContent += `Description: ${descriptionMatch[1]}\n`;
        }
      } catch (error) {
        console.error('Error processing document properties:', error);
      }
    }
    
    // Generate comprehensive business element breakdown
    const breakdown = {
      processes: businessElements.filter(e => e.type === 'Business Process').length,
      requirements: businessElements.filter(e => e.type === 'System Requirement').length,
      decisions: businessElements.filter(e => e.type === 'Decision Point').length,
      steps: businessElements.filter(e => e.type === 'Process Step').length,
      flows: businessElements.filter(e => e.type === 'Business Flow').length,
      userActions: businessElements.filter(e => e.type === 'User Action').length,
      shapes: businessElements.filter(e => e.type === 'Flowchart Shape').length,
      connectors: businessElements.filter(e => e.type === 'Connector').length
    };
    
    // Calculate total business elements (excluding technical shapes)
    const businessElementCount = businessElements.filter(e => 
      e.type !== 'Flowchart Shape' && e.type !== 'Connector'
    ).length;
    
    return {
      description: `Enhanced Visio flowchart analysis completed. Found ${businessElementCount} business elements across ${drawingFiles.length} pages.`,
      businessElements: {
        count: businessElementCount,
        elements: businessElements,
        breakdown
      },
      extractedContent,
      flowchartMetadata: {
        totalPages: drawingFiles.length,
        totalShapes: breakdown.shapes,
        totalConnectors: breakdown.connectors,
        hasDecisionPoints: breakdown.decisions > 0,
        hasProcessFlows: breakdown.flows > 0,
        complexity: calculateFlowchartComplexity(breakdown)
      }
    };
    
  } catch (error) {
    console.error(`Error analyzing Visio flowchart ${originalName}:`, error);
    return {
      description: `Error analyzing Visio flowchart: ${error.message}`,
      businessElements: {
        count: 0,
        elements: [],
        breakdown: {
          processes: 0,
          requirements: 0,
          decisions: 0,
          steps: 0,
          flows: 0,
          userActions: 0,
          shapes: 0,
          connectors: 0
        }
      },
      extractedContent: `# Visio Flowchart Analysis\n\n## File: ${originalName}\n\n### Error:\nFailed to analyze flowchart content: ${error.message}`,
      flowchartMetadata: {
        totalPages: 0,
        totalShapes: 0,
        totalConnectors: 0,
        hasDecisionPoints: false,
        hasProcessFlows: false,
        complexity: 'Unknown'
      }
    };
  }
}

/**
 * Analyze Visio XML content to extract shapes, text, and business elements
 * @param {string} xmlContent - XML content from Visio file
 * @param {string} context - Context identifier (page/drawing name)
 * @returns {Object} Analysis results with elements and content
 */
function analyzeVisioXmlContent(xmlContent, context) {
  const elements = [];
  let content = `\n\n### ${context}:\n`;
  
  try {
    // Extract text content from shapes
    const textMatches = xmlContent.match(/<Text[^>]*>(.*?)<\/Text>/gs);
    if (textMatches) {
      content += `\n#### Text Content:\n`;
      textMatches.forEach((textMatch, index) => {
        const textContent = textMatch.replace(/<\/?Text[^>]*>/g, '').trim();
        if (textContent.length > 0) {
          content += `- ${textContent}\n`;
          
          // Analyze text for business elements
          const businessElement = analyzeVisioTextForBusinessElements(textContent, index + 1, context);
          if (businessElement) {
            elements.push(businessElement);
          }
        }
      });
    }
    
    // Extract shape information
    const shapeMatches = xmlContent.match(/<Shape[^>]*>.*?<\/Shape>/gs);
    if (shapeMatches) {
      content += `\n#### Shapes and Elements:\n`;
      shapeMatches.forEach((shape, index) => {
        const shapeAnalysis = analyzeVisioShape(shape, index + 1, context);
        elements.push(shapeAnalysis.element);
        content += shapeAnalysis.content;
      });
    }
    
    // Extract connector information
    const connectorMatches = xmlContent.match(/<Connect[^>]*>/g);
    if (connectorMatches) {
      content += `\n#### Connectors and Flow:\n`;
      content += `Found ${connectorMatches.length} connections between elements\n`;
      
      // Add connector elements
      connectorMatches.forEach((connector, index) => {
        elements.push({
          type: 'Connector',
          text: `Connection ${index + 1}`,
          lineNumber: index + 1,
          section: context,
          priority: 'medium'
        });
      });
    }
    
  } catch (error) {
    console.error(`Error analyzing XML content for ${context}:`, error);
    content += `\nError analyzing content: ${error.message}\n`;
  }
  
  return { elements, content };
}

/**
 * Analyze Visio master shapes for additional business context
 * @param {string} masterXml - Master shapes XML content
 * @returns {Object} Master shapes analysis
 */
function analyzeVisioMasterShapes(masterXml) {
  const elements = [];
  let content = '';
  
  try {
    // Extract master shape names and properties
    const masterMatches = masterXml.match(/<Master[^>]*>.*?<\/Master>/gs);
    if (masterMatches) {
      content += `\n#### Master Shapes:\n`;
      masterMatches.forEach((master, index) => {
        const nameMatch = master.match(/Name="([^"]*)"/);
        const name = nameMatch ? nameMatch[1] : `Master ${index + 1}`;
        
        content += `- ${name}\n`;
        
        // Analyze master shape for business context
        if (name.toLowerCase().includes('decision') || name.toLowerCase().includes('diamond')) {
          elements.push({
            type: 'Decision Point',
            text: `Master Shape: ${name}`,
            lineNumber: index + 1,
            section: 'Master Shapes',
            priority: 'high'
          });
        } else if (name.toLowerCase().includes('process') || name.toLowerCase().includes('rectangle')) {
          elements.push({
            type: 'Process Step',
            text: `Master Shape: ${name}`,
            lineNumber: index + 1,
            section: 'Master Shapes',
            priority: 'medium'
          });
        } else if (name.toLowerCase().includes('start') || name.toLowerCase().includes('end')) {
          elements.push({
            type: 'Business Process',
            text: `Master Shape: ${name}`,
            lineNumber: index + 1,
            section: 'Master Shapes',
            priority: 'medium'
          });
        }
      });
    }
  } catch (error) {
    console.error('Error analyzing master shapes:', error);
    content += `\nError analyzing master shapes: ${error.message}\n`;
  }
  
  return { elements, content };
}

/**
 * Analyze individual Visio shape for business context
 * @param {string} shapeXml - Shape XML content
 * @param {number} index - Shape index
 * @param {string} context - Context section
 * @returns {Object} Shape analysis with element and content
 */
function analyzeVisioShape(shapeXml, index, context) {
  let content = `- Shape ${index}: `;
  
  // Extract shape type
  const typeMatch = shapeXml.match(/Type="([^"]*)"/);
  const type = typeMatch ? typeMatch[1] : 'Unknown';
  
  // Extract shape text
  const textMatch = shapeXml.match(/<Text[^>]*>(.*?)<\/Text>/);
  const text = textMatch ? textMatch[1].trim() : `Shape ${index}`;
  
  content += `${type} - "${text}"\n`;
  
  // Create shape element
  const element = {
    type: 'Flowchart Shape',
    text: text,
    lineNumber: index,
    section: context,
    priority: 'low',
    shapeType: type
  };
  
  return { element, content };
}

/**
 * Analyze Visio text content for business elements
 * @param {string} text - Text content from shape
 * @param {number} lineNumber - Line number for tracking
 * @param {string} context - Context section
 * @returns {Object|null} Business element if found
 */
function analyzeVisioTextForBusinessElements(text, lineNumber, context) {
  const lowerText = text.toLowerCase();
  
  // Decision points
  if (lowerText.includes('decision') || lowerText.includes('choice') || 
      lowerText.includes('if') || lowerText.includes('else') ||
      lowerText.includes('yes/no') || lowerText.includes('true/false')) {
    return {
      type: 'Decision Point',
      text: text,
      lineNumber: lineNumber,
      section: context,
      priority: 'high'
    };
  }
  
  // Process steps
  if (lowerText.includes('process') || lowerText.includes('step') || 
      lowerText.includes('action') || lowerText.includes('task') ||
      lowerText.includes('activity') || lowerText.includes('operation')) {
    return {
      type: 'Process Step',
      text: text,
      lineNumber: lineNumber,
      section: context,
      priority: 'medium'
    };
  }
  
  // Business processes
  if (lowerText.includes('business') || lowerText.includes('workflow') || 
      lowerText.includes('procedure') || lowerText.includes('method') ||
      lowerText.includes('system') || lowerText.includes('function')) {
    return {
      type: 'Business Process',
      text: text,
      lineNumber: lineNumber,
      section: context,
      priority: 'medium'
    };
  }
  
  // User actions
  if (lowerText.includes('user') || lowerText.includes('input') || 
      lowerText.includes('click') || lowerText.includes('select') ||
      lowerText.includes('enter') || lowerText.includes('submit')) {
    return {
      type: 'User Action',
      text: text,
      lineNumber: lineNumber,
      section: context,
      priority: 'medium'
    };
  }
  
  // System requirements
  if (lowerText.includes('requirement') || lowerText.includes('feature') || 
      lowerText.includes('validation') || lowerText.includes('check') ||
      lowerText.includes('verify') || lowerText.includes('ensure')) {
    return {
      type: 'System Requirement',
      text: text,
      lineNumber: lineNumber,
      section: context,
      priority: 'medium'
    };
  }
  
  // Business flows
  if (lowerText.includes('flow') || lowerText.includes('sequence') || 
      lowerText.includes('order') || lowerText.includes('path') ||
      lowerText.includes('route') || lowerText.includes('direction')) {
    return {
      type: 'Business Flow',
      text: text,
      lineNumber: lineNumber,
      section: context,
      priority: 'low'
    };
  }
  
  return null;
}

/**
 * Calculate flowchart complexity based on element counts
 * @param {Object} breakdown - Element breakdown
 * @returns {string} Complexity level
 */
function calculateFlowchartComplexity(breakdown) {
  const totalElements = breakdown.shapes + breakdown.connectors;
  const businessElements = breakdown.processes + breakdown.requirements + 
                          breakdown.decisions + breakdown.steps + 
                          breakdown.flows + breakdown.userActions;
  
  if (totalElements === 0) return 'Unknown';
  
  if (totalElements <= 10 && businessElements <= 5) return 'Simple';
  if (totalElements <= 25 && businessElements <= 15) return 'Moderate';
  if (totalElements <= 50 && businessElements <= 30) return 'Complex';
  return 'Very Complex';
}

// function cleanCache() {
//   
// }

// Helper function to create deterministic content hash
// function createDeterministicHash(buffer, filename) {
//   
//   return "no-cache";
// }

// Extract content from different file types
async function extractFileContent(file) {
  try {
    const buffer = file.buffer;
    const mimeType = file.mimetype;
    const originalName = file.originalname;
    const extension = path.extname(originalName);

    
    

    // Handle different file types
    if (mimeType === 'application/pdf') {
  
      
      try {
        const pdfData = await pdfParse(buffer);
        let extractedContent = pdfData.text;
        
        // Enhanced PDF processing to extract more structured content
        const lines = extractedContent.split('\n');
        let structuredContent = '';
        let currentSection = '';
        let inTable = false;
        let tableContent = '';
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // Detect headers and sections
          if (line.match(/^[A-Z][A-Z\s]+$/) || line.match(/^[0-9]+\.\s+[A-Z]/) || line.match(/^[A-Z][a-z]+(\s+[A-Z][a-z]+)*\s*$/)) {
            if (currentSection) {
              structuredContent += `\n\n## ${currentSection}\n`;
            }
            currentSection = line;
            structuredContent += `\n\n# ${line}\n`;
          }
          // Detect tables (lines with multiple spaces or tabs)
          else if (line.includes('  ') && line.split(/\s{2,}/).length > 2) {
            if (!inTable) {
              inTable = true;
              tableContent = '';
            }
            tableContent += line + '\n';
          }
          // Detect diagrams and charts (lines with special characters)
          else if (line.includes('â”Œ') || line.includes('â”œ') || line.includes('â””') || line.includes('â”‚') || 
                   line.includes('â”€') || line.includes('â”') || line.includes('â”¤') || line.includes('â”˜')) {
            structuredContent += `\n\n### Diagram/Chart Content:\n${line}\n`;
          }
          // Detect flow diagrams (lines with arrows)
          else if (line.includes('â†’') || line.includes('â†') || line.includes('â†‘') || line.includes('â†“') ||
                   line.includes('->') || line.includes('<-') || line.includes('=>') || line.includes('<=')) {
            structuredContent += `\n\n### Flow Diagram:\n${line}\n`;
          }
          else {
            if (inTable) {
              structuredContent += `\n\n### Table Content:\n${tableContent}\n`;
              inTable = false;
              tableContent = '';
            }
            structuredContent += line + '\n';
          }
        }
        
        if (inTable) {
          structuredContent += `\n\n### Table Content:\n${tableContent}\n`;
        }
        
        const result = structuredContent.trim();
        
        // Use universal business requirements extractor for consistent analysis
        const universalAnalysis = universalExtract(result, {
          minLineLength: 20,
          maxLineLength: 500,
          enableStrictMode: false,
          includeLowPriority: true
        });
        
        const enhancedResult = `${result}\n\n### Universal Business Element Analysis:\n- **Total Business Elements**: ${universalAnalysis.businessElements.count}\n- **Quality Score**: ${universalAnalysis.qualityMetrics.qualityScore}%\n- **High Confidence Elements**: ${universalAnalysis.qualityMetrics.highConfidenceElements}\n- **Testable Elements**: ${universalAnalysis.qualityMetrics.testableElements}\n\n### Element Breakdown:\n- **Business Processes**: ${universalAnalysis.businessElements.breakdown.byType['Business Process'] || 0}\n- **System Requirements**: ${universalAnalysis.businessElements.breakdown.byType['System Requirement'] || 0}\n- **Decision Points**: ${universalAnalysis.businessElements.breakdown.byType['Decision Point'] || 0}\n- **Process Steps**: ${universalAnalysis.businessElements.breakdown.byType['Process Step'] || 0}\n- **Business Rules**: ${universalAnalysis.businessElements.breakdown.byType['Business Rule'] || 0}\n- **User Actions**: ${universalAnalysis.businessElements.breakdown.byType['User Action'] || 0}\n- **Validation Requirements**: ${universalAnalysis.businessElements.breakdown.byType['Validation Requirement'] || 0}\n\n### Universal Analysis:\nThis universal business requirements extractor identified **${universalAnalysis.businessElements.count} business requirements** using consistent patterns across all file types. Quality Score: ${universalAnalysis.qualityMetrics.qualityScore}%`;
        
        return enhancedResult;
        
      } catch (error) {
        console.error(`Error processing PDF: ${error.message}`);
        const pdfData = await pdfParse(buffer);
        return pdfData.text;
      }
    } else if (mimeType === 'text/plain' || mimeType === 'text/markdown') {
      const textContent = buffer.toString('utf-8');
      
      // Use universal business requirements extractor for consistent analysis
      const universalAnalysis = universalExtract(textContent, {
        minLineLength: 20,
        maxLineLength: 500,
        enableStrictMode: false,
        includeLowPriority: true
      });
      
      const enhancedContent = `${textContent}\n\n### Universal Business Element Analysis:\n- **Total Business Elements**: ${universalAnalysis.businessElements.count}\n- **Quality Score**: ${universalAnalysis.qualityMetrics.qualityScore}%\n- **High Confidence Elements**: ${universalAnalysis.qualityMetrics.highConfidenceElements}\n- **Testable Elements**: ${universalAnalysis.qualityMetrics.testableElements}\n\n### Element Breakdown:\n- **Business Processes**: ${universalAnalysis.businessElements.breakdown.byType['Business Process'] || 0}\n- **System Requirements**: ${universalAnalysis.businessElements.breakdown.byType['System Requirement'] || 0}\n- **Decision Points**: ${universalAnalysis.businessElements.breakdown.byType['Decision Point'] || 0}\n- **Process Steps**: ${universalAnalysis.businessElements.breakdown.byType['Process Step'] || 0}\n- **Business Rules**: ${universalAnalysis.businessElements.breakdown.byType['Business Rule'] || 0}\n- **User Actions**: ${universalAnalysis.businessElements.breakdown.byType['User Action'] || 0}\n- **Validation Requirements**: ${universalAnalysis.businessElements.breakdown.byType['Validation Requirement'] || 0}\n\n### Universal Analysis:\nThis universal business requirements extractor identified **${universalAnalysis.businessElements.count} business requirements** using consistent patterns across all file types. Quality Score: ${universalAnalysis.qualityMetrics.qualityScore}%`;
      
      return enhancedContent;
    } else if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
               mimeType === 'application/msword' ||
               mimeType === 'application/rtf' ||
               mimeType === 'application/vnd.oasis.opendocument.text') {
      
  
      
      // Enhanced Word document processing for complex content including flow diagrams
      try {
        if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
          // For .docx files, extract from XML structure to get embedded content
          const zip = new JSZip();
          const zipContent = await zip.loadAsync(buffer);
          
          let extractedContent = '';
          
                  // Extract main document content with better text extraction
        if (zipContent.files['word/document.xml']) {
          const documentXml = await zipContent.files['word/document.xml'].async('string');
          
          // Extract text from paragraph tags for better structure
          const paragraphMatches = documentXml.match(/<w:p[^>]*>.*?<\/w:p>/gs);
          if (paragraphMatches) {
            extractedContent += `\n\nMain Document Content:\n`;
            paragraphMatches.forEach(paragraph => {
              const textMatches = paragraph.match(/<w:t[^>]*>(.*?)<\/w:t>/g);
              if (textMatches) {
                const paragraphText = textMatches
                  .map(text => text.replace(/<\/?w:t[^>]*>/g, ''))
                  .join(' ')
                  .trim();
                if (paragraphText.length > 5) {
                  extractedContent += `${paragraphText}\n`;
                }
              }
            });
          } else {
            // Fallback to basic text extraction
            const textContent = documentXml.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
            if (textContent.length > 10) {
              extractedContent += `\n\nMain Document Content:\n${textContent}`;
            }
          }
        }
          
          // Extract embedded objects and diagrams
          const embeddedFiles = Object.keys(zipContent.files).filter(file => 
            file.includes('word/embeddings/') || 
            file.includes('word/media/') ||
            file.includes('word/drawings/')
          );
          
  
          
          for (const embeddedFile of embeddedFiles) {
            try {
              const embeddedContent = await zipContent.files[embeddedFile].async('string');
              const textContent = embeddedContent.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
              if (textContent.length > 10) {
                extractedContent += `\n\nEmbedded Content (${embeddedFile}):\n${textContent}`;
              }
            } catch (error) {

            }
          }
          
          // Extract headers and footers
          const headerFiles = Object.keys(zipContent.files).filter(file => file.includes('word/header'));
          const footerFiles = Object.keys(zipContent.files).filter(file => file.includes('word/footer'));
          
          for (const headerFile of headerFiles) {
            try {
              const headerContent = await zipContent.files[headerFile].async('string');
              const textContent = headerContent.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
              if (textContent.length > 10) {
                extractedContent += `\n\nHeader Content:\n${textContent}`;
              }
            } catch (error) {
  
            }
          }
          
          if (extractedContent.trim()) {
            // Use universal business requirements extractor for consistent analysis
            const universalAnalysis = universalExtract(extractedContent, {
              minLineLength: 20,
              maxLineLength: 500,
              enableStrictMode: false,
              includeLowPriority: true
            });
            
            const enhancedContent = `${extractedContent}\n\n### Universal Business Element Analysis:\n- **Total Business Elements**: ${universalAnalysis.businessElements.count}\n- **Quality Score**: ${universalAnalysis.qualityMetrics.qualityScore}%\n- **High Confidence Elements**: ${universalAnalysis.qualityMetrics.highConfidenceElements}\n- **Testable Elements**: ${universalAnalysis.qualityMetrics.testableElements}\n\n### Element Breakdown:\n- **Business Processes**: ${universalAnalysis.businessElements.breakdown.byType['Business Process'] || 0}\n- **System Requirements**: ${universalAnalysis.businessElements.breakdown.byType['System Requirement'] || 0}\n- **Decision Points**: ${universalAnalysis.businessElements.breakdown.byType['Decision Point'] || 0}\n- **Process Steps**: ${universalAnalysis.businessElements.breakdown.byType['Process Step'] || 0}\n- **Business Rules**: ${universalAnalysis.businessElements.breakdown.byType['Business Rule'] || 0}\n- **User Actions**: ${universalAnalysis.businessElements.breakdown.byType['User Action'] || 0}\n- **Validation Requirements**: ${universalAnalysis.businessElements.breakdown.byType['Validation Requirement'] || 0}\n\n### Universal Analysis:\nThis universal business requirements extractor identified **${universalAnalysis.businessElements.count} business requirements** using consistent patterns across all file types. Quality Score: ${universalAnalysis.qualityMetrics.qualityScore}%`;
            
            return enhancedContent;
          }
        }
        
        // Fallback to mammoth for other Word formats
        const result = await mammoth.extractRawText({ buffer });
        
        const extractedContent = result.value;
        
        // Use universal business requirements extractor for consistent analysis
        const universalAnalysis = universalExtract(extractedContent, {
          minLineLength: 20,
          maxLineLength: 500,
          enableStrictMode: false,
          includeLowPriority: true
        });
        
        const enhancedContent = `${extractedContent}\n\n### Universal Business Element Analysis:\n- **Total Business Elements**: ${universalAnalysis.businessElements.count}\n- **Quality Score**: ${universalAnalysis.qualityMetrics.qualityScore}%\n- **High Confidence Elements**: ${universalAnalysis.qualityMetrics.highConfidenceElements}\n- **Testable Elements**: ${universalAnalysis.qualityMetrics.testableElements}\n\n### Element Breakdown:\n- **Business Processes**: ${universalAnalysis.businessElements.breakdown.byType['Business Process'] || 0}\n- **System Requirements**: ${universalAnalysis.businessElements.breakdown.byType['System Requirement'] || 0}\n- **Decision Points**: ${universalAnalysis.businessElements.breakdown.byType['Decision Point'] || 0}\n- **Process Steps**: ${universalAnalysis.businessElements.breakdown.byType['Process Step'] || 0}\n- **Business Rules**: ${universalAnalysis.businessElements.breakdown.byType['Business Rule'] || 0}\n- **User Actions**: ${universalAnalysis.businessElements.breakdown.byType['User Action'] || 0}\n- **Validation Requirements**: ${universalAnalysis.businessElements.breakdown.byType['Validation Requirement'] || 0}\n\n### Universal Analysis:\nThis universal business requirements extractor identified **${universalAnalysis.businessElements.count} business requirements** using consistent patterns across all file types. Quality Score: ${universalAnalysis.qualityMetrics.qualityScore}%`;
        
        return enhancedContent;
        
      } catch (error) {
        console.error(`Error processing Word document: ${error.message}`);
        // Fallback to basic mammoth extraction
        const result = await mammoth.extractRawText({ buffer });
        
        const extractedContent = result.value;
        
        
        
        
        return extractedContent;
      }
    } else if (isImageFile(mimeType, extension)) {
      // Enhanced image analysis with deterministic counting
      const imageAnalysis = analyzeImageContent(originalName, extension);
      
      const result = `# Image File Analysis\n\n## File: ${originalName}\n\n### Image Type: ${extension.toUpperCase()}\n\n### Analysis:\n${imageAnalysis.description}\n\n### Business Element Analysis:\n- **Total Business Elements**: ${imageAnalysis.businessElements.count}\n- **Business Processes**: ${imageAnalysis.businessElements.breakdown.processes}\n- **System Requirements**: ${imageAnalysis.businessElements.breakdown.requirements}\n- **Decision Points**: ${imageAnalysis.businessElements.breakdown.decisions}\n- **Process Steps**: ${imageAnalysis.businessElements.breakdown.steps}\n- **Business Flows**: ${imageAnalysis.businessElements.breakdown.flows}\n- **User Actions**: ${imageAnalysis.businessElements.breakdown.userActions}\n\n### Deterministic Count:\nThis analysis identified **${imageAnalysis.businessElements.count} business requirements** based on image content analysis.\n\n### Note:\nThis is an image file that may require manual review or OCR processing for detailed text extraction.`;
      
      
      
      
      return result;
    } else if (isExcelFile(mimeType, extension)) {
  
      
      try {
        const zip = new JSZip();
        const zipContent = await zip.loadAsync(buffer);
        
        let extractedContent = '';
        
        // Extract workbook structure and sheet names
        if (zipContent.files['xl/workbook.xml']) {
          const workbookXml = await zipContent.files['xl/workbook.xml'].async('string');
          const sheetMatches = workbookXml.match(/<sheet[^>]*name="([^"]*)"[^>]*>/g);
          if (sheetMatches) {
            extractedContent += `\n\n## Workbook Structure:\n`;
            sheetMatches.forEach((match, index) => {
              const nameMatch = match.match(/name="([^"]*)"/);
              if (nameMatch) {
                extractedContent += `Sheet ${index + 1}: ${nameMatch[1]}\n`;
              }
            });
          }
        }
        
        // Extract all worksheets
        const worksheetFiles = Object.keys(zipContent.files).filter(file => 
          file.includes('xl/worksheets/sheet') && file.endsWith('.xml')
        );
        

        
        for (const worksheetFile of worksheetFiles) {
          try {
            const worksheetXml = await zipContent.files[worksheetFile].async('string');
            
            extractedContent += `\n\n### Worksheet: ${worksheetFile}\n`;
            
                    // Extract only meaningful text content (headers, labels, business logic)
        const textMatches = worksheetXml.match(/<t>(.*?)<\/t>/g);
        if (textMatches) {
          const meaningfulTexts = textMatches
            .map(text => text.replace(/<\/?t>/g, '').trim())
            .filter(text => text.length > 3 && !text.match(/^[0-9]+$/) && !text.match(/^[A-Z\s]+$/)); // Filter out numbers, very short text, and ALL CAPS
          
          if (meaningfulTexts.length > 0) {
            extractedContent += `\n#### Business Content:\n`;
            meaningfulTexts.forEach(text => {
              extractedContent += `${text}\n`;
            });
          }
        }
        
        // Enhanced business element detection for Excel - analyze actual content
        const businessElements = [];
        let elementCount = 0;
        
        // Extract meaningful business content from the actual text
        const lines = extractedContent.split('\n').filter(line => line.trim().length > 0);
        
        lines.forEach((line, index) => {
          const trimmedLine = line.trim();
          
          // Skip very short lines and generic headers
          if (trimmedLine.length < 10) return;
          
          // Detect business processes from content
          if (trimmedLine.toLowerCase().includes('process') || 
              trimmedLine.toLowerCase().includes('workflow') ||
              trimmedLine.toLowerCase().includes('procedure')) {
            businessElements.push({
              type: 'Business Process',
              text: trimmedLine,
              lineNumber: elementCount++,
              section: 'Excel Analysis'
            });
          }
          
          // Detect system requirements from content
          else if (trimmedLine.toLowerCase().includes('requirement') || 
                   trimmedLine.toLowerCase().includes('feature') ||
                   trimmedLine.toLowerCase().includes('functionality')) {
            businessElements.push({
              type: 'System Requirement',
              text: trimmedLine,
              lineNumber: elementCount++,
              section: 'Excel Analysis'
            });
          }
          
          // Detect user actions from content
          else if (trimmedLine.toLowerCase().includes('user') || 
                   trimmedLine.toLowerCase().includes('action') ||
                   trimmedLine.toLowerCase().includes('step')) {
            businessElements.push({
              type: 'User Action',
              text: trimmedLine,
              lineNumber: elementCount++,
              section: 'Excel Analysis'
            });
          }
          
          // Detect decision points from content
          else if (trimmedLine.toLowerCase().includes('decision') || 
                   trimmedLine.toLowerCase().includes('condition') ||
                   trimmedLine.toLowerCase().includes('if') ||
                   trimmedLine.toLowerCase().includes('when')) {
            businessElements.push({
              type: 'Decision Point',
              text: trimmedLine,
              lineNumber: elementCount++,
              section: 'Excel Analysis'
            });
          }
          
          // Detect business rules and scenarios
          else if (trimmedLine.toLowerCase().includes('scenario') || 
                   trimmedLine.toLowerCase().includes('rule') ||
                   trimmedLine.toLowerCase().includes('business') ||
                   trimmedLine.toLowerCase().includes('acceptance')) {
            businessElements.push({
              type: 'Business Rule',
              text: trimmedLine,
              lineNumber: elementCount++,
              section: 'Excel Analysis'
            });
          }
          
          // Detect numbered or bulleted items as potential requirements
          else if (trimmedLine.match(/^[0-9]+\.\s+/) || 
                   trimmedLine.match(/^[0-9]+\)\s+/) ||
                   trimmedLine.match(/^[â€¢\-*]\s+/)) {
            businessElements.push({
              type: 'System Requirement',
              text: trimmedLine,
              lineNumber: elementCount++,
              section: 'Excel Analysis'
            });
          }
        });
        
        // If no business elements detected, add a default one
        if (businessElements.length === 0) {
          businessElements.push({
            type: 'Business Process',
            text: 'Excel Data Analysis Required - Manual Review Recommended',
            lineNumber: elementCount++,
            section: 'Excel Analysis'
          });
        }
            
            // Extract sheet structure info (column headers, row headers)
            const headerMatches = worksheetXml.match(/<c[^>]*r="[A-Z]+1"[^>]*>.*?<v>(.*?)<\/v>.*?<\/c>/gs);
            if (headerMatches) {
              const headers = headerMatches
                .map(header => header.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim())
                .filter(header => header.length > 0);
              
              if (headers.length > 0) {
                extractedContent += `\n#### Column Headers:\n`;
                headers.forEach(header => {
                  extractedContent += `- ${header}\n`;
                });
              }
            }
          } catch (error) {

          }
        }
        
        // Extract charts and embedded objects
        const chartFiles = Object.keys(zipContent.files).filter(file => 
          file.includes('xl/charts/') || file.includes('xl/drawings/')
        );
        
        if (chartFiles.length > 0) {
          extractedContent += `\n\n### Charts and Diagrams:\n`;
          chartFiles.forEach(chartFile => {
            extractedContent += `- ${chartFile}\n`;
          });
        }
        
        // Extract shared strings (for better text extraction)
        if (zipContent.files['xl/sharedStrings.xml']) {
          const sharedStringsXml = await zipContent.files['xl/sharedStrings.xml'].async('string');
          const stringMatches = sharedStringsXml.match(/<t>(.*?)<\/t>/g);
          if (stringMatches) {
            extractedContent += `\n\n### Shared Strings Content:\n`;
            stringMatches.forEach(stringMatch => {
              const stringText = stringMatch.replace(/<\/?t>/g, '').trim();
              if (stringText.length > 3 && !stringText.match(/^[0-9]+$/) && !stringText.match(/^[A-Z\s]+$/)) {
                extractedContent += `${stringText}\n`;
              }
            });
          }
        }
        
        if (extractedContent.trim()) {
          // Use deterministic counting for business elements
          const businessElementCount = detectBusinessElements(extractedContent);
          
          const result = `# Excel Spreadsheet Analysis\n\n## File: ${originalName}\n\n### Extracted Content:\n${extractedContent.trim()}\n\n### Business Element Analysis:\n- **Total Business Elements**: ${businessElementCount.count}\n- **Business Processes**: ${businessElementCount.breakdown.processes}\n- **System Requirements**: ${businessElementCount.breakdown.requirements}\n- **Decision Points**: ${businessElementCount.breakdown.decisions}\n- **Process Steps**: ${businessElementCount.breakdown.steps}\n- **Business Flows**: ${businessElementCount.breakdown.flows}\n- **User Actions**: ${businessElementCount.breakdown.userActions}\n\n### Deterministic Count:\nThis analysis identified **${businessElementCount.count} business requirements** based on actual content analysis.`;
          
          
          
          
          
          
          
          // console.log(`ðŸ“‹ Processed content`);
          
          return result;
        } else {
          const result = `# Excel Spreadsheet Analysis\n\n## File: ${originalName}\n\n### Note:\nThis Excel file contains structured data that should be reviewed manually to create appropriate test cases based on the data relationships and business logic.`;
          
          
          
          return result;
        }
      } catch (zipError) {
        console.error(`Error processing Excel file ${originalName}:`, zipError);
        
        const errorResult = `# Excel Spreadsheet Analysis\n\n## File: ${originalName}\n\n### Note:\nThis Excel file contains structured data that requires manual analysis to create appropriate test cases.`;
        
        
        
        
        return errorResult;
      }
    } else if (isPowerPointFile(mimeType, extension)) {
  
      
      try {
        const zip = new JSZip();
        const zipContent = await zip.loadAsync(buffer);
        
        let extractedContent = '';
        
        // Extract presentation structure
        if (zipContent.files['ppt/presentation.xml']) {
          const presentationXml = await zipContent.files['ppt/presentation.xml'].async('string');
          const slideMatches = presentationXml.match(/<sldId[^>]*id="([^"]*)"[^>]*rid="([^"]*)"[^>]*>/g);
          if (slideMatches) {
            extractedContent += `\n\n## Presentation Structure:\n`;
            extractedContent += `Found ${slideMatches.length} slides in presentation\n`;
          }
        }
        
        // Extract all slides
        const slideFiles = Object.keys(zipContent.files).filter(file => 
          file.includes('ppt/slides/slide') && file.endsWith('.xml')
        );
        

        
        for (let i = 0; i < slideFiles.length; i++) {
          const slideFile = slideFiles[i];
          try {
            const slideXml = await zipContent.files[slideFile].async('string');
            
            extractedContent += `\n\n### Slide ${i + 1}:\n`;
            
            // Extract slide text content
            const textMatches = slideXml.match(/<a:t>(.*?)<\/a:t>/g);
            if (textMatches) {
              extractedContent += `\n#### Text Content:\n`;
              textMatches.forEach(textMatch => {
                const textContent = textMatch.replace(/<\/?a:t>/g, '').trim();
                if (textContent.length > 0) {
                  extractedContent += `- ${textContent}\n`;
                }
              });
            }
            
            // Extract shapes and diagrams
            const shapeMatches = slideXml.match(/<p:sp[^>]*>.*?<\/p:sp>/gs);
            if (shapeMatches) {
              extractedContent += `\n#### Shapes and Diagrams:\n`;
              shapeMatches.forEach(shape => {
                const shapeText = shape.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                if (shapeText.length > 10) {
                  extractedContent += `- Shape: ${shapeText}\n`;
                }
              });
            }
            
            // Enhanced business element detection for PowerPoint
            const businessElements = [];
            let elementCount = 0;
            
            // Detect business processes from slide content
            if (textMatches && textMatches.some(text => 
              text.toLowerCase().includes('process') || 
              text.toLowerCase().includes('workflow') ||
              text.toLowerCase().includes('business')
            )) {
              businessElements.push({
                type: 'Business Process',
                text: `Slide ${i + 1} Business Process Content`,
                lineNumber: elementCount++,
                section: 'PowerPoint Analysis'
              });
            }
            
            // Detect system requirements from slide content
            if (textMatches && textMatches.some(text => 
              text.toLowerCase().includes('requirement') || 
              text.toLowerCase().includes('feature') ||
              text.toLowerCase().includes('system')
            )) {
              businessElements.push({
                type: 'System Requirement',
                text: `Slide ${i + 1} System Requirements`,
                lineNumber: elementCount++,
                section: 'PowerPoint Analysis'
              });
            }
            
            // Detect user actions from slide content
            if (textMatches && textMatches.some(text => 
              text.toLowerCase().includes('user') || 
              text.toLowerCase().includes('action') ||
              text.toLowerCase().includes('click')
            )) {
              businessElements.push({
                type: 'User Action',
                text: `Slide ${i + 1} User Actions`,
                lineNumber: elementCount++,
                section: 'PowerPoint Analysis'
              });
            }
            
            // Detect decision points from slide content
            if (textMatches && textMatches.some(text => 
              text.toLowerCase().includes('decision') || 
              text.toLowerCase().includes('condition') ||
              text.toLowerCase().includes('if')
            )) {
              businessElements.push({
                type: 'Decision Point',
                text: `Slide ${i + 1} Decision Points`,
                lineNumber: elementCount++,
                section: 'PowerPoint Analysis'
              });
            }
            
            // Extract animations and transitions
            const animationMatches = slideXml.match(/<p:anim[^>]*>.*?<\/p:anim>/gs);
            if (animationMatches) {
              extractedContent += `\n#### Animations:\n`;
              animationMatches.forEach(animation => {
                const animationText = animation.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                if (animationText.length > 5) {
                  extractedContent += `- Animation: ${animationText}\n`;
                }
              });
            }
            
          } catch (error) {

          }
        }
        
        // Extract embedded media and objects
        const mediaFiles = Object.keys(zipContent.files).filter(file => 
          file.includes('ppt/media/') || file.includes('ppt/embeddings/')
        );
        
        if (mediaFiles.length > 0) {
          extractedContent += `\n\n### Embedded Media:\n`;
          mediaFiles.forEach(mediaFile => {
            extractedContent += `- ${mediaFile}\n`;
          });
        }
        
        // Extract slide masters for layout information
        const masterFiles = Object.keys(zipContent.files).filter(file => 
          file.includes('ppt/slideMasters/')
        );
        
        if (masterFiles.length > 0) {
          extractedContent += `\n\n### Slide Layouts:\n`;
          masterFiles.forEach(masterFile => {
            extractedContent += `- ${masterFile}\n`;
          });
        }
        
        if (extractedContent.trim()) {
          // Use deterministic counting for business elements
          const businessElementCount = detectBusinessElements(extractedContent);
          
          const result = `# PowerPoint Presentation Analysis\n\n## File: ${originalName}\n\n### Extracted Content:\n${extractedContent.trim()}\n\n### Business Element Analysis:\n- **Total Business Elements**: ${businessElementCount.count}\n- **Business Processes**: ${businessElementCount.breakdown.processes}\n- **System Requirements**: ${businessElementCount.breakdown.requirements}\n- **Decision Points**: ${businessElementCount.breakdown.decisions}\n- **Process Steps**: ${businessElementCount.breakdown.steps}\n- **Business Flows**: ${businessElementCount.breakdown.flows}\n- **User Actions**: ${businessElementCount.breakdown.userActions}\n\n### Deterministic Count:\nThis analysis identified **${businessElementCount.count} business requirements** based on actual content analysis.`;
          
          
          
          
          
          
          
          // console.log(`ðŸ“‹ Processed content`);
          
          return result;
        } else {
          const result = `# PowerPoint Presentation Analysis\n\n## File: ${originalName}\n\n### Note:\nThis PowerPoint presentation contains visual elements that should be reviewed manually to create appropriate test cases based on the presentation content and flow.`;
          
          
          
          return result;
        }
      } catch (zipError) {
        console.error(`Error processing PowerPoint file ${originalName}:`, zipError);
        
        const errorResult = `# PowerPoint Presentation Analysis\n\n## File: ${originalName}\n\n### Note:\nThis PowerPoint presentation contains visual elements that require manual analysis to create appropriate test cases.`;
        
        
        
        
        return errorResult;
      }
    } else if (isVisioFile(mimeType, extension)) {
      try {
        // Use enhanced Visio flowchart analysis
        const analysis = await analyzeVisioFlowchart(buffer, originalName);
        
        if (analysis.businessElements.count > 0) {
          // Use universal business requirements extractor for consistent analysis
          const universalAnalysis = universalExtract(analysis.extractedContent, {
            minLineLength: 20,
            maxLineLength: 500,
            enableStrictMode: false,
            includeLowPriority: true
          });
          
          const result = `# Enhanced Visio Flowchart Analysis\n\n## File: ${originalName}\n\n### Flowchart Metadata:\n- **Total Pages**: ${analysis.flowchartMetadata.totalPages}\n- **Total Shapes**: ${analysis.flowchartMetadata.totalShapes}\n- **Total Connectors**: ${analysis.flowchartMetadata.totalConnectors}\n- **Has Decision Points**: ${analysis.flowchartMetadata.hasDecisionPoints ? 'Yes' : 'No'}\n- **Has Process Flows**: ${analysis.flowchartMetadata.hasProcessFlows ? 'Yes' : 'No'}\n- **Complexity Level**: ${analysis.flowchartMetadata.complexity}\n\n### Extracted Content:\n${analysis.extractedContent}\n\n### Universal Business Element Analysis:\n- **Total Business Elements**: ${universalAnalysis.businessElements.count}\n- **Quality Score**: ${universalAnalysis.qualityMetrics.qualityScore}%\n- **High Confidence Elements**: ${universalAnalysis.qualityMetrics.highConfidenceElements}\n- **Testable Elements**: ${universalAnalysis.qualityMetrics.testableElements}\n\n### Element Breakdown:\n- **Business Processes**: ${universalAnalysis.businessElements.breakdown.byType['Business Process'] || 0}\n- **System Requirements**: ${universalAnalysis.businessElements.breakdown.byType['System Requirement'] || 0}\n- **Decision Points**: ${universalAnalysis.businessElements.breakdown.byType['Decision Point'] || 0}\n- **Process Steps**: ${universalAnalysis.businessElements.breakdown.byType['Process Step'] || 0}\n- **Business Rules**: ${universalAnalysis.businessElements.breakdown.byType['Business Rule'] || 0}\n- **User Actions**: ${universalAnalysis.businessElements.breakdown.byType['User Action'] || 0}\n- **Validation Requirements**: ${universalAnalysis.businessElements.breakdown.byType['Validation Requirement'] || 0}\n\n### Enhanced Analysis:\n${analysis.description}\n\n### Universal Analysis:\nThis universal business requirements extractor identified **${universalAnalysis.businessElements.count} business requirements** using consistent patterns across all file types. Quality Score: ${universalAnalysis.qualityMetrics.qualityScore}%`;
          
          return result;
        } else {
          const result = `# Enhanced Visio Flowchart Analysis\n\n## File: ${originalName}\n\n### Note:\nThis Visio flowchart file was analyzed but no business elements were detected. The diagram may contain visual elements that require manual review to identify business requirements.`;
          
          return result;
        }
      } catch (zipError) {
        console.error(`Error processing Visio file ${originalName}:`, zipError);
        
        const errorResult = `# Enhanced Visio Flowchart Analysis\n\n## File: ${originalName}\n\n### Error:\nFailed to analyze flowchart content: ${zipError.message}\n\n### Note:\nThis Visio flowchart file requires manual analysis. Please review the diagram structure and create test cases based on the visual elements and relationships.`;
        
        return errorResult;
      }
    } else {
      throw new Error(`Unsupported file type: ${mimeType}`);
    }
  } catch (error) {
    console.error(`Error extracting content from ${file.originalname}:`, error);
    
    
    
    throw new Error(`Failed to extract content from ${file.originalname}: ${error.message}`);
  }
}

// Process document sections
function processDocumentSections(content, fileName) {
  const sections = [];
  const lines = content.split('\n');
  let currentSection = '';
  let currentSectionTitle = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    if (line.startsWith('#') || line.startsWith('##') || line.startsWith('###')) {
      // Save previous section if exists
      if (currentSection.trim()) {
        sections.push({
          title: currentSectionTitle || `Section ${sections.length + 1}`,
          content: currentSection.trim()
        });
      }
      
      // Start new section
      currentSectionTitle = line.replace(/^#+\s*/, '');
      currentSection = line + '\n';
    } else {
      currentSection += line + '\n';
    }
  }
  
  // Add the last section
  if (currentSection.trim()) {
    sections.push({
      title: currentSectionTitle || `Section ${sections.length + 1}`,
      content: currentSection.trim()
    });
  }
  
  // If no sections found, create a single section
  if (sections.length === 0) {
    sections.push({
      title: `Content from ${fileName}`,
      content: content.trim()
    });
  }
  
  return sections;
}

module.exports = {
  extractFileContent,
  processDocumentSections,
  isImageFile,
  isExcelFile,
  isPowerPointFile,
  isVisioFile,
  // Deterministic counting functions
  countBusinessElementsDeterministically,
  detectBusinessElements,
  
  // Enhanced Visio analysis
  analyzeVisioFlowchart,
  
  // Configuration adjustment function
  adjustBusinessElementConfig
}; 